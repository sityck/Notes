# 容器逃逸

目前接触的一种是容器OS内核或云技术组件漏洞导致的逃逸，这一类型实际上是NDAY漏洞的利用；另一种是不安全配置导致的漏洞，这一类型主要是因为在业务或管理平面开放或配置了过多的能力导致

## 已知漏洞逃逸



## 不安全配置导致的逃逸

对于一个对外开放的创建容器的能力在设计开发时应该慎之又慎，对于用户可以填充的启动参数应该使用白名单的设计机制，让用户无法通过恶意挂载、恶意配置来创建一个可以逃逸的容器。同时，如果有提供一个初始容器，应该注意其配置于挂载的文件，避免出现因不安全配置/挂载导致的逃逸问题。

### --privileged：特权模式运行容器

原始命令：`docker run --privileged`

当一个容器以特权模式运行时，其能够访问宿主机上的所有设备，可以通过挂载宿主机磁盘等手段获取宿主机的权限（这个权限应该是与docker运行用户的权限一致的）。

**测试思路：**对于一个提供容器能力的平台，其自然不会直接运行一个以特权模式运行的容器，通常来讲，我们需要寻找平台上开放的容器运行参数配置的相关能力及接口；特权模式能够在yaml或conf文件中配置，或者在封装的接口中也会提供对应的能力，我们需要注意开发是否将相关的能力屏蔽（仅仅前端隐藏是不够的）；假设一个容器平台没有将对应的能力限制，那么我们可以运行一个特权模式的容器，通过恶意挂载来访问宿主机的敏感文件，达到容器逃逸的效果。

### --cap-add=ALL：为容器添加所有特权

原始命令：`docker run --cap-add=ALL`

这个命令实际上是和特权模式运行容器的效果是一致的，但是其不如特权模式的缺陷而广为人知，在特权模式受到限制时，可以尝试这个命令是否也受到限制。

### 挂载Docker  Socket的情况

关键步骤：`在容器内挂载/var/run/docker.sock`

当Docker Socket被挂载到容器内时，我们通过在容器内安装docker命令行客户端，即可通过该客户端于docker进程通信；这时只需在原容器内通过docker命令创建一个新容器并挂载宿主机根目录，再通过新容器切换到挂载的宿主机根目录里，即可实现逃逸。理论上来讲，当我们能够通过命令行创建新容器时，就已经逃逸了。

### 挂载procfs的情况

背景：procfs是一个伪文件系统，它动态反映系统内进程及其他组件的状态，包含许多敏感、重要文件。

前提：容器内默认启用root权限、没有开启User Namespace

该情况的关键在于/proc/sys/kernel/core_pattern从内核2.6.19版本开始，支持程序或脚本运行，只需使首个字符为管道符“|”。那么假设procfs被我们挂载到了容器里面，并且此时我们容器的root权限为真实root权限，我们通过在core_pattern中注入后门代码，在容器内写好反弹shell，并运行一个会崩溃的程序即可触发宿主机的反弹shell

> 开启了user namespace的root权限是虚假的，可以通过以下步骤检查，如果出现文件链接则说明开启了user namespace：
>
> 进入/proc/目录
>
> $cd /proc/
>
> 查看当前目录下有哪些文件或目录
>
> $ls
>
> 随便进入一个以数字（进程号）命名的目录，比如1
>
> $cd 1
>
> 查看ns（Namespace）目录下的内容
>
> $ls -al ns

**步骤一：植入后门。**`echo -e "| /tmp/.x.py \rcore    " > /proc/sys/kernrl/core_pattern`

需要注意的是该tmp目录为容器目录，我们需要修改为宿主机的绝对路径，可通过`cat /proc/mounts | grep docker`获取容器的绝对工作路径，`${工作路径}/../merged`即为容器的根路径，作为上方tmp目录的前缀即可注入。

**步骤二：在容器内创建反弹shell。**在容器内的/tmp.x.py文件写入反弹shell，并在攻击机器上启动监听：`ncat -lvnp $port`

**步骤三：在容器内运行可以崩溃的程序。**示例代码如下：

```c++
#include <stdio.h>

int main(void){

int *a = NULL;

*a = 1;

return 0;}
```

### 任意挂载的情况

当用户可以调用API进行任意挂载时，可以使用--volume /:/host、--pid=host、--net=host等配置来打破容器与宿主机的资源隔离。
